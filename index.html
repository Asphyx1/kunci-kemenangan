<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sepak Bola Carrom: V4 (Bug Fixed)</title>
    <style>
        body {
            margin: 0;
            background-color: #1e272e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 40px rgba(0,0,0,0.6);
            border: 8px solid #d2dae2;
            border-radius: 15px;
        }

        canvas {
            background: #218c74;
            display: block;
            cursor: crosshair;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
            z-index: 5;
        }

        .score-box { text-align: center; }
        .score-num { font-size: 2.5em; font-weight: 900; display: block; line-height: 1; }
        .score-label { font-size: 0.8em; opacity: 0.8; font-weight: bold; }
        
        #red-score .score-num { color: #ff5e57; }
        #blue-score .score-num { color: #0fb9b1; }

        #timer-box {
            background: rgba(0,0,0,0.6);
            padding: 5px 20px;
            border-radius: 10px;
            border: 2px solid white;
            text-align: center;
        }
        #timer-val { font-size: 2em; font-weight: bold; color: #ffd32a; }
        #timer-label { font-size: 0.7em; text-transform: uppercase; letter-spacing: 2px; }

        #turn-indicator {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            padding: 8px 20px;
            border-radius: 30px;
            font-size: 1.1em;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: 0.3s;
            z-index: 5;
        }

        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            text-align: center;
        }
        
        .modal h1 { font-size: 3em; margin: 0 0 20px 0; color: #ffd32a; }
        
        button {
            padding: 15px 40px;
            font-size: 1.5em;
            background: linear-gradient(to bottom, #ffdd59, #ffc048);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 800;
            color: #333;
            box-shadow: 0 5px 0 #e58e26;
            transition: 0.1s;
        }
        button:active { transform: translateY(5px); box-shadow: none; }
        .hidden { display: none !important; }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="field" width="800" height="500"></canvas>
        
        <div id="ui-layer">
            <div id="red-score" class="score-box">
                <span class="score-label">MERAH</span>
                <span class="score-num">0</span>
            </div>
            
            <div id="timer-box">
                <div id="timer-val">30</div>
                <div id="timer-label">Detik</div>
            </div>

            <div id="blue-score" class="score-box">
                <span class="score-label">BIRU</span>
                <span class="score-num">0</span>
            </div>
        </div>
        
        <div id="turn-indicator">Giliran: ...</div>

        <div id="start-screen" class="modal">
            <h1>⚽ SOCCER BATTLE ⚽</h1>
            <p style="color:white; margin-bottom: 30px;">Tarik pemain, tembak bola, cetak 5 gol!</p>
            <button onclick="startCoinToss()">MULAI (GACHA KOIN)</button>
        </div>

        <div id="game-over-screen" class="modal hidden">
            <h1 id="winner-text">MERAH MENANG!</h1>
            <button onclick="resetGame()">MAIN LAGI</button>
        </div>
    </div>

<script>
    // --- KONFIGURASI ---
    const canvas = document.getElementById('field');
    const ctx = canvas.getContext('2d');
    
    const MAX_SCORE = 5;
    const TURN_TIME_LIMIT = 30; 
    const POWERUP_LIFETIME = 10000; 
    
    const FRICTION = 0.97; 
    const PLAYER_RADIUS = 20;
    const BALL_RADIUS = 12;
    const GOAL_SIZE = 130;

    const POWERUP_SPOTS = [
        {x: 400, y: 250}, 
        {x: 200, y: 125}, 
        {x: 200, y: 375}, 
        {x: 600, y: 125}, 
        {x: 600, y: 375} 
    ];

    let players = [];
    let ball = { x: 400, y: 250, vx: 0, vy: 0, color: '#f5f6fa' };
    let activePowerUp = null; 
    
    let isRedTurn = true;
    let isMoving = false;
    let scores = { red: 0, blue: 0 };
    
    let turnTimerValue = TURN_TIME_LIMIT;
    let turnTimerInterval = null;
    let powerUpTimeout = null;

    let dragInfo = { 
        active: false, 
        startX: 0, startY: 0, 
        currentX: 0, currentY: 0, 
        selectedPlayer: null 
    };

    function initPositions() {
        ball.x = canvas.width / 2;
        ball.y = canvas.height / 2;
        ball.vx = 0; ball.vy = 0;

        players = [];
        players.push({ x: 100, y: 250, vx: 0, vy: 0, team: 'red', color: '#ff5e57', boosted: false });
        players.push({ x: 250, y: 150, vx: 0, vy: 0, team: 'red', color: '#ff5e57', boosted: false });
        players.push({ x: 250, y: 350, vx: 0, vy: 0, team: 'red', color: '#ff5e57', boosted: false });

        players.push({ x: 700, y: 250, vx: 0, vy: 0, team: 'blue', color: '#0fb9b1', boosted: false });
        players.push({ x: 550, y: 150, vx: 0, vy: 0, team: 'blue', color: '#0fb9b1', boosted: false });
        players.push({ x: 550, y: 350, vx: 0, vy: 0, team: 'blue', color: '#0fb9b1', boosted: false });

        activePowerUp = null;
    }

    function startTurn() {
        clearInterval(turnTimerInterval);
        turnTimerValue = TURN_TIME_LIMIT;
        updateTimerUI();
        
        turnTimerInterval = setInterval(() => {
            if (isMoving) return; 

            turnTimerValue--;
            updateTimerUI();
            
            if (turnTimerValue <= 0) {
                clearInterval(turnTimerInterval);
                alert("⏱️ WAKTU HABIS! Giliran Hangus!");
                switchTurn();
            }
        }, 1000);

        spawnRandomPowerUp();
        
        const ind = document.getElementById('turn-indicator');
        ind.innerText = isRedTurn ? "GILIRAN: TIM MERAH" : "GILIRAN: TIM BIRU";
        ind.style.color = isRedTurn ? "#ff5e57" : "#0fb9b1";
    }

    function switchTurn() {
        isRedTurn = !isRedTurn;
        startTurn();
    }

    function updateTimerUI() {
        const el = document.getElementById('timer-val');
        el.innerText = turnTimerValue;
        el.style.color = turnTimerValue <= 10 ? "#ff3f34" : "#ffd32a"; 
    }

    function spawnRandomPowerUp() {
        activePowerUp = null; 
        clearTimeout(powerUpTimeout);

        const randIndex = Math.floor(Math.random() * POWERUP_SPOTS.length);
        const spot = POWERUP_SPOTS[randIndex];

        activePowerUp = {
            x: spot.x,
            y: spot.y,
            radius: 15,
            spawnTime: Date.now()
        };

        powerUpTimeout = setTimeout(() => {
            if(activePowerUp) {
                activePowerUp = null; 
            }
        }, POWERUP_LIFETIME);
    }

    function update() {
        let movementDetected = false;

        players.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vx *= FRICTION;
            p.vy *= FRICTION;

            if (p.x - PLAYER_RADIUS < 0) { p.x = PLAYER_RADIUS; p.vx *= -0.8; }
            if (p.x + PLAYER_RADIUS > canvas.width) { p.x = canvas.width - PLAYER_RADIUS; p.vx *= -0.8; }
            if (p.y - PLAYER_RADIUS < 0) { p.y = PLAYER_RADIUS; p.vy *= -0.8; }
            if (p.y + PLAYER_RADIUS > canvas.height) { p.y = canvas.height - PLAYER_RADIUS; p.vy *= -0.8; }

            if (Math.abs(p.vx) > 0.05 || Math.abs(p.vy) > 0.05) movementDetected = true;
        });

        ball.x += ball.vx;
        ball.y += ball.vy;
        ball.vx *= FRICTION;
        ball.vy *= FRICTION;

        if (ball.y - BALL_RADIUS < 0) { ball.y = BALL_RADIUS; ball.vy *= -0.8; }
        if (ball.y + BALL_RADIUS > canvas.height) { ball.y = canvas.height - BALL_RADIUS; ball.vy *= -0.8; }
        
        let inGoalZone = (ball.y > (canvas.height - GOAL_SIZE)/2 && ball.y < (canvas.height + GOAL_SIZE)/2);
        if (ball.x - BALL_RADIUS < 0) {
            if (inGoalZone) handleGoal('blue');
            else { ball.x = BALL_RADIUS; ball.vx *= -0.8; }
        }
        if (ball.x + BALL_RADIUS > canvas.width) {
            if (inGoalZone) handleGoal('red');
            else { ball.x = canvas.width - BALL_RADIUS; ball.vx *= -0.8; }
        }

        if (Math.abs(ball.vx) > 0.05 || Math.abs(ball.vy) > 0.05) movementDetected = true;

        resolveCollisions();
        
        // BUG FIX DISINI: Panggil fungsi yang aman
        checkPowerUpCollectionSafe(); 

        if (isMoving && !movementDetected) {
            isMoving = false;
            switchTurn(); 
        }
        if (movementDetected) isMoving = true;

        draw();
        requestAnimationFrame(update);
    }

    function resolveCollisions() {
        players.forEach(p => {
            let dx = ball.x - p.x;
            let dy = ball.y - p.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let minDist = PLAYER_RADIUS + BALL_RADIUS;

            if (dist < minDist) {
                let angle = Math.atan2(dy, dx);
                let force = p.boosted ? 2.5 : 1.5; 
                
                if(p.boosted) p.boosted = false;

                let overlap = minDist - dist;
                ball.x += Math.cos(angle) * overlap;
                ball.y += Math.sin(angle) * overlap;

                let speedP = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
                ball.vx += Math.cos(angle) * speedP * force;
                ball.vy += Math.sin(angle) * speedP * force;
                
                p.vx *= 0.5;
                p.vy *= 0.5;
            }
        });

        for (let i = 0; i < players.length; i++) {
            for (let j = i + 1; j < players.length; j++) {
                let p1 = players[i];
                let p2 = players[j];
                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                let minDist = PLAYER_RADIUS * 2;

                if (dist < minDist) {
                    let angle = Math.atan2(dy, dx);
                    let overlap = (minDist - dist) / 2;
                    p1.x -= Math.cos(angle) * overlap;
                    p1.y -= Math.sin(angle) * overlap;
                    p2.x += Math.cos(angle) * overlap;
                    p2.y += Math.sin(angle) * overlap;

                    let tx = Math.cos(angle), ty = Math.sin(angle);
                    let dpTan1 = p1.vx * ty - p1.vy * tx;
                    let dpTan2 = p2.vx * ty - p2.vy * tx;
                    let dpNorm1 = p1.vx * tx + p1.vy * ty;
                    let dpNorm2 = p2.vx * tx + p2.vy * ty;
                    let m = 1; 
                    let mom1 = (dpNorm1 * 0 + 2 * m * dpNorm2) / (2*m);
                    let mom2 = (dpNorm2 * 0 + 2 * m * dpNorm1) / (2*m);
                    p1.vx = tx * mom1 - ty * dpTan1;
                    p1.vy = ty * mom1 + tx * dpTan1;
                    p2.vx = tx * mom2 - ty * dpTan2;
                    p2.vy = ty * mom2 + tx * dpTan2;
                }
            }
        }
    }

    // --- PERBAIKAN BUG CRASH ---
    function checkPowerUpCollectionSafe() {
        if (!activePowerUp) return; 

        // Kita pakai loop manual biar bisa 'break' kalau powerup udah diambil
        for (let i = 0; i < players.length; i++) {
            
            // Cek dobel (Safety Check)
            if (!activePowerUp) break; 

            let p = players[i];
            let dx = p.x - activePowerUp.x;
            let dy = p.y - activePowerUp.y;
            let dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < PLAYER_RADIUS + activePowerUp.radius) {
                // Kena! Hapus powerup
                activePowerUp = null;
                clearTimeout(powerUpTimeout);
                p.boosted = true; 
                
                // Visual Effect
                ctx.save();
                ctx.fillStyle = "yellow";
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 50, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();

                break; // PENTING: Stop loop langsung biar gak error ke pemain berikutnya
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(canvas.width/2, 0); ctx.lineTo(canvas.width/2, canvas.height); ctx.stroke();
        ctx.beginPath(); ctx.arc(canvas.width/2, canvas.height/2, 70, 0, Math.PI*2); ctx.stroke();

        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(0, (canvas.height - GOAL_SIZE)/2, 8, GOAL_SIZE);
        ctx.fillRect(canvas.width-8, (canvas.height - GOAL_SIZE)/2, 8, GOAL_SIZE);

        if (activePowerUp) {
            let timeLeft = (activePowerUp.spawnTime + POWERUP_LIFETIME) - Date.now();
            if (timeLeft > 3000 || Math.floor(Date.now() / 200) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(activePowerUp.x, activePowerUp.y, activePowerUp.radius, 0, Math.PI*2);
                ctx.fillStyle = '#fbc531';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'black';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("⚡", activePowerUp.x, activePowerUp.y + 6);
            }
        }

        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.strokeStyle = '#2f3640';
        ctx.stroke();

        players.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, PLAYER_RADIUS, 0, Math.PI*2);
            ctx.fillStyle = p.color;
            ctx.fill();
            
            if (p.boosted) {
                ctx.strokeStyle = '#fbc531'; 
                ctx.lineWidth = 4;
            } else {
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 1;
            }
            ctx.stroke();

            if ((isRedTurn && p.team === 'red') || (!isRedTurn && p.team === 'blue')) {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
                ctx.fill();
            }
        });

        if (dragInfo.active && dragInfo.selectedPlayer) {
            ctx.beginPath();
            ctx.moveTo(dragInfo.selectedPlayer.x, dragInfo.selectedPlayer.y);
            ctx.lineTo(dragInfo.currentX, dragInfo.currentY);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 10]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    function handleGoal(scorer) {
        scores[scorer]++;
        document.querySelector(`#${scorer}-score .score-num`).innerText = scores[scorer];
        
        document.body.style.transform = "translate(5px, 5px)";
        setTimeout(() => document.body.style.transform = "none", 100);

        if (scores[scorer] >= MAX_SCORE) {
            endGame(scorer);
        } else {
            initPositions();
            isMoving = false;
            clearInterval(turnTimerInterval); 
            setTimeout(() => startTurn(), 1000); 
        }
    }

    function startCoinToss() {
        document.getElementById('start-screen').classList.add('hidden');
        
        let toss = Math.random() < 0.5;
        isRedTurn = toss;
        alert("Koin dilempar... " + (isRedTurn ? "MERAH" : "BIRU") + " Jalan Duluan!");
        
        initPositions();
        startTurn();
        update();
    }

    function endGame(winner) {
        clearInterval(turnTimerInterval);
        document.getElementById('game-over-screen').classList.remove('hidden');
        const winText = winner === 'red' ? "MERAH JUARA!" : "BIRU JUARA!";
        document.getElementById('winner-text').innerText = winText;
        document.getElementById('winner-text').style.color = winner === 'red' ? '#ff5e57' : '#0fb9b1';
    }

    function resetGame() {
        scores = { red: 0, blue: 0 };
        document.querySelector('#red-score .score-num').innerText = '0';
        document.querySelector('#blue-score .score-num').innerText = '0';
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('start-screen').classList.remove('hidden');
    }

    window.addEventListener('mousedown', (e) => checkStartDrag(e.clientX, e.clientY));
    window.addEventListener('touchstart', (e) => checkStartDrag(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
    
    window.addEventListener('mousemove', (e) => updateDrag(e.clientX, e.clientY));
    window.addEventListener('touchmove', (e) => { if(dragInfo.active) e.preventDefault(); updateDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
    
    window.addEventListener('mouseup', endDrag);
    window.addEventListener('touchend', endDrag);

    function getCanvasPos(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    function checkStartDrag(cx, cy) {
        if (isMoving) return;
        
        const rect = canvas.getBoundingClientRect();
        if (cx < rect.left || cx > rect.right || cy < rect.top || cy > rect.bottom) return;

        const pos = getCanvasPos(cx, cy);
        
        players.forEach(p => {
            let dist = Math.hypot(pos.x - p.x, pos.y - p.y);
            if (dist < PLAYER_RADIUS * 1.5) { 
                if ((isRedTurn && p.team === 'red') || (!isRedTurn && p.team === 'blue')) {
                    dragInfo.active = true;
                    dragInfo.selectedPlayer = p;
                    dragInfo.startX = p.x;
                    dragInfo.startY = p.y;
                    dragInfo.currentX = p.x;
                    dragInfo.currentY = p.y;
                }
            }
        });
    }

    function updateDrag(cx, cy) {
        if (!dragInfo.active) return;
        const pos = getCanvasPos(cx, cy);
        dragInfo.currentX = pos.x;
        dragInfo.currentY = pos.y;
    }

    function endDrag() {
        if (!dragInfo.active) return;

        let dx = dragInfo.startX - dragInfo.currentX;
        let dy = dragInfo.startY - dragInfo.currentY;
        
        let rawPower = Math.hypot(dx, dy);
        let power = Math.min(rawPower, 200) * 0.15; 
        
        if (power > 1) { 
            let angle = Math.atan2(dy, dx);
            dragInfo.selectedPlayer.vx = Math.cos(angle) * power;
            dragInfo.selectedPlayer.vy = Math.sin(angle) * power;
            isMoving = true;
            clearInterval(turnTimerInterval); 
        }

        dragInfo.active = false;
        dragInfo.selectedPlayer = null;
    }

</script>
</body>
</html>
